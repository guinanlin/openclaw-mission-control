# 飞书配对：如何确认 CLI 与发码网关一致

执行 `openclaw pairing approve feishu <码>` 时若报 **「No pending pairing request found for code: xxx」**，常见原因是：**CLI 连的网关** 和 **发码的网关** 不是同一个。配对码是由「某台 Gateway」生成的，只有连到同一台 Gateway 才能查到该待处理请求。

## 1. 确认 CLI 当前用的是哪个网关

OpenClaw CLI 按以下优先级决定连哪个 Gateway（先匹配到的为准）：

| 方式 | 说明 |
|------|------|
| **环境变量** | `OPENCLAW_GATEWAY_URL`，例如 `export OPENCLAW_GATEWAY_URL=ws://127.0.0.1:18789` |
| **配置文件** | `~/.openclaw/openclaw.json` 里的 `gateway.remote.url`（连远程 Gateway 时） |
| **默认** | 未设置时多为本机：`ws://127.0.0.1:18789`（端口来自 `gateway.port`，默认 18789） |

**怎么查当前 CLI 用的地址：**

```bash
# 看环境变量
echo $OPENCLAW_GATEWAY_URL

# 看配置文件里的远程 URL（若存在）
openclaw config get gateway.remote.url

# 看本机 gateway 端口（本地模式时 CLI 会连本机该端口）
openclaw config get gateway.port
# 本地未指定 remote 时，一般为 ws://127.0.0.1:<上述端口>
```

`pairing approve` 子命令**不支持** `--url` / `--token` 等选项，网关地址需通过**环境变量**或**配置文件**指定：

```bash
# 方式一：环境变量（推荐，只对当前终端生效）
export OPENCLAW_GATEWAY_URL=ws://localhost:18789
export OPENCLAW_GATEWAY_TOKEN=b92cd55e0b13dec68a55d5300cae48d8370079816fedf932   # 若网关需要 token
openclaw pairing approve feishu <配对码>

# 方式二：单行临时指定（同一行中 export 后直接执行）
OPENCLAW_GATEWAY_URL=ws://localhost:18789 openclaw pairing approve feishu <配对码>
```

## 2. 确认「发码」的是哪个网关

配对码是**用户从飞书发起配对时**，由**当时连上的那一台 OpenClaw Gateway** 生成的。因此：

- **发码的网关** = 飞书应用所连接的那台 Gateway（跑着 OpenClaw、并处理飞书请求的那台）。
- 若使用 **Mission Control**，且飞书与 Mission Control 共用同一台 Gateway，则：
  - 在 Mission Control 里 **Gateways** 页面看到的某个 Gateway 的 **Gateway URL**，就是「发码」用的那个地址。

**在 Mission Control 里查看：**

1. 打开 **Gateways** 列表/详情页。
2. 找到飞书/Agent 实际使用的那台 Gateway。
3. 记下其 **Gateway URL**（例如 `ws://10.0.2.235:18789` 或 `ws://127.0.0.1:18789`）。

若飞书连的是本机直接跑的 OpenClaw（未通过 Mission Control 配置），则发码的网关就是本机正在跑的 gateway 进程对应的地址（例如 `ws://127.0.0.1:18789` 或 LAN IP）。

## 3. 对照两者是否一致

| 项目 | 如何得到 |
|------|----------|
| **CLI 用的网关** | `echo $OPENCLAW_GATEWAY_URL`、`openclaw config get gateway.remote.url`、或默认 `ws://127.0.0.1:<gateway.port>` |
| **发码的网关** | Mission Control 里该 Gateway 的 **Gateway URL**，或本机/LAN 上实际跑 gateway 的地址 |

两者必须一致（协议、主机、端口都相同；若网关带 token，CLI 也要带同一 token）。

**常见不一致情况：**

- 发码的是 **LAN 上的某台机**（如 `ws://10.0.2.235:18789`），CLI 却用默认 **127.0.0.1:18789**（连到了本机另一台或没连到发码的那台）。
- 本机开了多个 gateway 进程，端口不同，CLI 连的是 A 端口，飞书连的是 B 端口。

**处理办法：** 用环境变量让 CLI 连到发码的网关，再执行 approve：

```bash
export OPENCLAW_GATEWAY_URL=ws://10.0.2.235:18789   # 换成你在 MC 里看到的或实际发码的地址
# 若该网关需要 token：
export OPENCLAW_GATEWAY_TOKEN=<你的gateway-token>
openclaw pairing approve feishu <新配对码>
```

配对码有时效，若已过期请先在飞书重新发起配对，再对**新码**执行上述命令。

---

## 查看当前待处理配对请求

确认 Gateway 上是否有待处理的飞书配对请求：

```bash
openclaw pairing list feishu
```

需带上 channel（飞书为 `feishu`），否则会报错「Channel required」。可在飞书里发起配对后立刻执行该命令，若有新请求会列出，再用对应配对码执行 `openclaw pairing approve feishu <码>`。

---

## 如何让飞书再产生配对码

配对码是**机器人收到「未配对用户」的私聊消息时**自动回复的。要让飞书再产生一个新配对码：

1. **用尚未配对过的飞书账号**：在飞书里找一个**从未和该机器人配对过**的账号（可以是你的小号、同事账号等）。
2. **打开与机器人的私聊**：在飞书中找到你的 OpenClaw 机器人（应用/机器人名称）。
3. **发一条消息**：给机器人发任意一条私聊消息（例如「你好」或「配对」）。
4. **机器人会回复配对码**：默认策略（`dmPolicy: "pairing"`）下，机器人会自动回复一个**新的配对码**。
5. **立刻在终端执行**：
   ```bash
   openclaw pairing list feishu    # 确认请求已出现
   openclaw pairing approve feishu <飞书里显示的新码>
   ```

**说明**：若用**已经配对过的飞书账号**再发消息，机器人不会重复发配对码，会直接正常对话。所以要「新码」就必须用未配对过的账号发消息，或依赖 OpenClaw/飞书侧是否有「解除配对」后重新触发的机制（请以官方文档为准）。
